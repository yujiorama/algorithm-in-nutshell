(define (swap v a b)
  (let ((tmp (vector-ref v a)))
    (vector-set! v a (vector-ref v b))
    (vector-set! v b tmp)))

(define (isort list cmp-fn)
  (define last (length list))
  (define (iter vec pos value)
    (let ((i (- pos 1)))
      (while (and (>= i 0) (cmp-fn (vector-ref vec i) value))
             (vector-set! vec (+ i 1) (vector-ref vec i))
             (set! i (- i 1)))
      (vector-set! vec (+ i 1) value)))
  (let ((i 1)
        (vec (list->vector list)))
    (while (< i last)
           (iter vec i (vector-ref vec i))
           (set! i (+ i 1)))
    (vector->list vec)))

(define (medsort list cmp-fn)
  (define (find v l r)
    (let ((k (+ 1 l)))
      (while (and (< k r) (>= (cmp-fn (vector-ref v k) (vector-ref v l)) 0))
             (set! k (+ k 1)))
      k))
  (define (select-median v l r)
    (vector-ref v (+ l 1)))
  (define (select-pivot-index v l r)
    l)
  (define (partition v l r pivot-index)
    (let ((pivot-value (vector-ref v pivot-index))
          (idx l)
          (store l))
      (swap v r pivot-index)
      (while (< idx r)
             (if (<= (cmp-fn (vector-ref v idx) pivot-value) 0)
                 (begin
                   (swap v idx store)
                   (set! store (+ store 1))))
             (set! idx (+ idx 1)))
      (swap v r store)
      store))
  (define (select-Kth v k l r)
    (let* ((idx (select-pivot-index v l r))
           (pivot-index (partition v l r idx)))
      (cond ((= pivot-index (+ l (- k 1)))
             pivot-index)
            ((> pivot-index (+ l (- k 1)))
             (select-Kth v k l (- pivot-index 1)))
            (else
             (select-Kth v (- k (+ (- pivot-index l) 1)) (+ pivot-index 1) r)))))
  (define (iter vec left right)
    (if (< left right)
        (let* ((mid (floor (/ (- right (- left 1)) 2)))
              (me (select-Kth vec (+ 1 mid) left right)))
          (iter vec left (+ left (- mid 1)))
          (iter vec (+ left mid 1) right))))
  (let ((vec (list->vector list)))
    (iter vec 0 (- (length list) 1))
    (vector->list vec)))

(define (qsort list cmp-fn)
  (define (select-one l r)
    (+ (floor (/ (- r l) 2)) l))
  (define (partition v l r)
    (let ((p (select-one l r))
          (store l)
          (i l))
      (swap v p r)
      (while (< i r)
             (if (>= (cmp-fn (vector-ref v r) (vector-ref v i)) 0)
                 (begin
                   (swap v i store)
                   (set! store (+ 1 store))))
             (set! i (+ i 1)))
      (swap v store r)
      store))
  (define (inner v left right)
    (if (< left right)
        (let ((pi (partition v left right)))
          (inner v left (- pi 1))
          (inner v (+ pi 1) right))))
  (let ((vec (list->vector list)))
    (inner vec 0 (- (length list) 1))
    (vector->list vec)))

(define (heapsort list cmp-fn)
  (define (heapify v idx max)
    (let ((left (+ (* 2 idx) 1))
          (right (+ (* 2 idx) 2))
          (largest 0))
      (if (and (< left max) (> (cmp-fn (vector-ref v left) (vector-ref v idx)) 0))
          (set! largest left)
          (set! largest idx))
      (if (and (< right max) (> (cmp-fn (vector-ref v right) (vector-ref v largest)) 0))
          (set! largest right))
      (if (not (= largest idx))
          (begin
            (swap v idx largest)
            (heapify v largest max)))))
  (define (build-heap v)
    (let ((i (- (floor (/ (vector-length v) 2)) 1)))
      (while (>= i 0)
             (heapify v i (vector-length v))
             (set! i (- i 1)))))
  (let ((vec (list->vector list))
        (i (- (length list) 1)))
    (build-heap vec)
    (while (> i 0)
           (swap vec 0 i)
           (heapify vec 0 i)
           (set! i (- i 1)))
    (vector->list vec)))

(use gauche.test)
(test-start "sort")
(test-section "insert sort")
(define num-list '(3 9 6 5 1 9 4 7 4 1 2 0 2 4 1 5 0))
(define (numeric-cmp a b) (> a b))
(test* "num-list sort" '(0 0 1 1 1 2 2 3 4 4 4 5 5 6 7 9 9) (isort num-list numeric-cmp))
(set! num-list '(1 1 3 4 8 2 9 0 3 0 9 8 3 1 6 8))
(test* "num-list sort2" '(0 0 1 1 1 2 3 3 3 4 6 8 8 8 9 9) (isort num-list numeric-cmp))
(test-section "median sort")
(define (numeric-cmp a b) (cond ((> a b) 1) ((= a b) 0) (else -1)))
(set! num-list '(3 9 6 5 1 9 4 7 4 1 2 0 2 4 1 5 0))
(test* "median-list sort" '(0 0 1 1 1 2 2 3 4 4 4 5 5 6 7 9 9) (medsort num-list numeric-cmp))
(set! num-list '(1 1 3 4 8 2 9 0 3 0 9 8 3 1 6 8))
(test* "median-list sort2" '(0 0 1 1 1 2 3 3 3 4 6 8 8 8 9 9) (medsort num-list numeric-cmp))

(test-section "quick sort")
(set! num-list '(3 9 6 5 1 9 4 7 4 1 2 0 2 4 1 5 0))
(test* "quick-list sort" '(0 0 1 1 1 2 2 3 4 4 4 5 5 6 7 9 9) (qsort num-list numeric-cmp))
(set! num-list '(1 1 3 4 8 2 9 0 3 0 9 8 3 1 6 8))
(test* "quick-list sort2" '(0 0 1 1 1 2 3 3 3 4 6 8 8 8 9 9) (qsort num-list numeric-cmp))

(test-section "heap sort")
(set! num-list '(3 9 6 5 1 9 4 7 4 1 2 0 2 4 1 5 0))
(test* "heap-list sort" '(0 0 1 1 1 2 2 3 4 4 4 5 5 6 7 9 9) (heapsort num-list numeric-cmp))
(set! num-list '(1 1 3 4 8 2 9 0 3 0 9 8 3 1 6 8))
(test* "heap-list sort2" '(0 0 1 1 1 2 3 3 3 4 6 8 8 8 9 9) (heapsort num-list numeric-cmp))

(test-end)
